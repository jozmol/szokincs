<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Kiejt√©s Gyakorl√≥</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display:flex; flex-direction:column; align-items:center; padding:20px; color:white; }
        .container { max-width:800px; width:100%; background:white; border-radius:15px; box-shadow:0 10px 30px rgba(0,0,0,0.2); overflow:hidden; margin-top:20px; color:#333; }
        header { background: linear-gradient(to right, #e52d27, #b31217); color:white; padding:30px 20px; text-align:center; }
        h1 { font-size:2.5rem; margin-bottom:10px; }
        .subtitle { font-size:1.1rem; opacity:0.9; }
        .content { padding:30px; }
        .settings-section{ background:#f8f9fa; padding:20px; border-radius:10px; margin-bottom:25px; text-align:center; }
        .settings-title { font-size:1.2rem; font-weight:bold; margin-bottom:15px; color:#333; }
        .settings-row { display:flex; justify-content:center; gap:20px; flex-wrap:wrap; margin-bottom:20px; align-items:center; }
        .select-wrapper { position:relative; min-width:200px; }
        .word-count-select { width:100%; padding:12px 15px; border:2px solid #2196F3; border-radius:8px; background:white; color:#333; font-size:1rem; cursor:pointer; }
        .start-btn { background:#4CAF50; color:white; border:none; padding:12px 30px; border-radius:25px; font-size:1.1rem; font-weight:bold; cursor:pointer; transition:all 0.3s; }
        .start-btn:hover { background:#3d8b40; transform:scale(1.05); }
        .practice-info { margin-top:10px; font-size:0.9rem; color:#666; }
        .word-section { text-align:center; margin-bottom:30px; }
        .chinese-word { font-size:4rem; margin-bottom:10px; color:#e52d27; font-weight:bold; }
        .pinyin { font-size:2rem; color:#666; margin-bottom:20px; }
        .tts-info { background-color:#e3f2fd; padding:10px; margin:10px 20px; border-radius:8px; font-size:0.9rem; text-align:center; border-left:4px solid #2196F3; }
        .meaning { font-size:1.3rem; color:#333; margin-bottom:30px; }
        .recording-section { background:#f8f9fa; padding:25px; border-radius:10px; margin-bottom:25px; text-align:center; }
        .recording-btn { background:#4CAF50; color:white; border:none; padding:15px 30px; border-radius:50px; font-size:1.1rem; font-weight:bold; cursor:pointer; margin:10px; transition:all 0.3s; }
        .recording-btn:hover { background:#3d8b40; transform:scale(1.05); }
        .recording-btn.recording { background:#e52d27; animation:pulse 1.5s infinite; }
        .recording-btn:disabled { background:#cccccc; cursor:not-allowed; transform:none; }
        @keyframes pulse { 0%{transform:scale(1);}50%{transform:scale(1.05);}100%{transform:scale(1);} }
        .recognition-controls { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
        .feedback { margin-top:20px; padding:15px; border-radius:8px; text-align:center; font-weight:bold; min-height:80px; display:flex; flex-direction:column; justify-content:center; align-items:center; }
        .feedback.good { background-color:#e8f5e9; color:#2e7d32; border:1px solid #c8e6c9; }
        .feedback.needs-work { background-color:#fff3cd; color:#856404; border:1px solid #ffeaa7; }
        .feedback.perfect { background-color:#e3f2fd; color:#1565c0; border:1px solid #bbdefb; }
        .controls { display:flex; justify-content:center; gap:15px; margin-top:20px; flex-wrap:wrap; }
        .control-btn { padding:12px 25px; border:none; border-radius:8px; font-size:1rem; font-weight:bold; cursor:pointer; transition:all 0.3s; }
        .listen-btn{ background:#2196F3; color:white; } .next-btn{ background:#FF9800; color:white; } .new-session-btn{ background:#607D8B; color:white; }
        .control-btn:hover { transform:translateY(-2px); }
        .progress { margin-top:20px; text-align:center; color:#666; font-size:1.1rem; font-weight:bold; }
        .progress-bar { width:100%; height:8px; background:#e0e0e0; border-radius:4px; margin-top:5px; overflow:hidden; }
        .progress-fill { height:100%; background:linear-gradient(to right,#4CAF50,#45a049); transition:width 0.3s ease; }
        .recording-status { margin-top:10px; color:#666; font-size:0.9rem; }
        .audio-visualizer { width:100%; height:80px; border:1px solid #ddd; border-radius:8px; margin:15px 0; display:none; }
        .hidden{ display:none; }
        @media (max-width:600px){ .chinese-word{font-size:3rem;} .pinyin{font-size:1.5rem;} .controls{flex-direction:column; align-items:center;} .control-btn{width:100%; max-width:250px;} .settings-row{flex-direction:column; gap:10px;} .select-wrapper{width:100%;} .recognition-controls{flex-direction:column;} }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Pronunciation Practice</h1>
            <div class="subtitle">Practice pronouncing English words</div>
        </header>

        <div class="tts-info">
            üîä Click "Start Recording", speak the word, then click "Analyze" ‚Äî or use the fallback if your browser doesn't support speech recognition.
        </div>

        <div class="progress hidden" id="progress-section">
            <div id="progress">0/0</div>
            <div class="progress-bar"><div class="progress-fill" id="progress-fill" style="width:0%"></div></div>
        </div>

        <div class="content">
            <div class="settings-section" id="settings-section">
                <div class="settings-title">üéØ Choose how many words to practice</div>
                <div class="settings-row">
                    <div class="select-wrapper">
                        <select class="word-count-select" id="word-count-select">
                            <option value="5">5 words</option>
                            <option value="7" selected>7 words</option>
                            <option value="10">10 words</option>
                            <option value="0">All words</option>
                        </select>
                    </div>
                    <button class="start-btn" id="start-btn">üöÄ Start exercise</button>
                </div>
                <div class="practice-info" id="practice-info">Total words: <span id="total-words">All</span> words</div>
            </div>

            <div class="word-section hidden" id="word-section">
                <div class="chinese-word" id="chinese-word">***</div>
                <div class="pinyin" id="pinyin">***</div>
                <div class="meaning" id="meaning">***</div>
            </div>

            <div class="recording-section hidden" id="recording-section">
                <div class="recognition-controls">
                    <button class="recording-btn" id="record-btn">üé§ Start Recording</button>
                    <button class="recording-btn" id="stop-btn" disabled>‚èπÔ∏è Stop Recording</button>
                    <button class="recording-btn" id="analyze-btn" disabled>üîç Analyze</button>
                </div>

                <canvas class="audio-visualizer" id="audio-visualizer"></canvas>

                <div class="recording-status" id="recording-status">Click "Start Recording", speak, then "Analyze"</div>

                <div class="feedback" id="feedback"></div>
            </div>

            <div class="controls hidden" id="controls">
                <button class="control-btn listen-btn" id="listen-btn">üîä Listen English</button>
                <button class="control-btn next-btn" id="next-btn">‚û°Ô∏è Next word</button>
                <button class="control-btn new-session-btn" id="new-session-btn">üîÑ New exercise</button>
            </div>
        </div>
    </div>

    <script>
    // --- ADATOK (Sz√≥t√°r) ---
    const fullWordDictionary = [
        { english: "thank you", pinyin: "thank you", meaning: "Ë∞¢Ë∞¢" },
        { english: "good day", pinyin: "good day", meaning: "‰Ω†Â•Ω" },
        { english: "I love you", pinyin: "I love you", meaning: "ÊàëÁà±‰Ω†" },
        { english: "hello", pinyin: "hello", meaning: "‰Ω†Â•Ω" },
        { english: "water", pinyin: "water", meaning: "Ê∞¥" },
        { english: "mother", pinyin: "mother", meaning: "Â¶àÂ¶à" },
        { english: "friend", pinyin: "friend", meaning: "ÊúãÂèã" },
        { english: "breakfast", pinyin: "breakfast", meaning: "Êó©È§ê" },
        { english: "lunch", pinyin: "lunch", meaning: "ÂçàÈ§ê"},
        { english: "dinner", pinyin: "dinner", meaning: "ÊôöÈ§ê"},
        { english: "soup", pinyin: "soup", meaning: "Ê±§"},
        { english: "salad", pinyin: "salad", meaning: "Ê≤ôÊãâ"},
        { english: "sandwich", pinyin: "sandwich", meaning: "‰∏âÊòéÊ≤ª"},
        { english: "hamburger", pinyin: "hamburger", meaning: "Ê±âÂ†°" },
        { english: "pizza", pinyin: "pƒ´s√†", meaning: "Êä´Ëê®" },
        { english: "spaghetti", pinyin: "y√¨d√†l√¨ mi√†n", meaning: "ÊÑèÂ§ßÂà©Èù¢" },
        { english: "rice", pinyin: "m«êf√†n", meaning: "Á±≥È•≠" },
        { english: "noodles", pinyin: "mi√†nti√°o", meaning: "Èù¢Êù°" },
        { english: "dumpling", pinyin: "ji«éozi", meaning: "È•∫Â≠ê" },
        { english: "steamed bun", pinyin: "bƒÅozi", meaning: "ÂåÖÂ≠ê" },
        { english: "steamed bread", pinyin: "m√°ntou", meaning: "È¶íÂ§¥" },
        { english: "cake", pinyin: "d√†ngƒÅo", meaning: "ËõãÁ≥ï" },
        { english: "cookie", pinyin: "b«ênggƒÅn", meaning: "È•ºÂπ≤" },
        { english: "chocolate", pinyin: "qi«éok√®l√¨", meaning: "Â∑ßÂÖãÂäõ" },
        { english: "ice cream", pinyin: "bƒ´ngq√≠l√≠n", meaning: "ÂÜ∞Ê∑áÊ∑ã" },
        { english: "candy", pinyin: "t√°nggu«í", meaning: "Á≥ñÊûú" },
        { english: "apple", pinyin: "p√≠nggu«í", meaning: "ËãπÊûú" },
        { english: "banana", pinyin: "xiƒÅngjiƒÅo", meaning: "È¶ôËïâ" },
        { english: "orange", pinyin: "ch√©ngzi", meaning: "Ê©ôÂ≠ê" },
        { english: "strawberry", pinyin: "c«éom√©i", meaning: "ËçâËéì" },
        { english: "grape", pinyin: "p√∫t√°o", meaning: "Ëë°ËêÑ" },
        { english: "watermelon", pinyin: "xƒ´guƒÅ", meaning: "Ë•øÁìú" },
        { english: "tomato", pinyin: "xƒ´h√≥ngsh√¨", meaning: "Ë•øÁ∫¢Êüø" },
        { english: "carrot", pinyin: "h√∫lu√≥bo", meaning: "ËÉ°ËêùÂçú" },
        { english: "potato", pinyin: "t«îd√≤u", meaning: "ÂúüË±Ü" },
        { english: "onion", pinyin: "y√°ngc≈çng", meaning: "Ê¥ãËë±" },
        { english: "garlic", pinyin: "d√†su√†n", meaning: "Â§ßËíú" },
        { english: "milk", pinyin: "ni√∫n«éi", meaning: "ÁâõÂ•∂" },
        { english: "juice", pinyin: "gu«ízhƒ´", meaning: "ÊûúÊ±Å" },
        { english: "cola", pinyin: "kƒõl√®", meaning: "ÂèØ‰πê" },
        { english: "mineral water", pinyin: "ku√†ngqu√°n shu«ê", meaning: "ÁüøÊ≥âÊ∞¥" },
        { english: "red wine", pinyin: "h√≥ngji«î", meaning: "Á∫¢ÈÖí" },
        { english: "liquor", pinyin: "b√°iji«î", meaning: "ÁôΩÈÖí" },
        { english: "cocktail", pinyin: "jƒ´wƒõiji«î", meaning: "È∏°Â∞æÈÖí" },
        { english: "whisky", pinyin: "wƒìish√¨j√¨", meaning: "Â®ÅÂ£´Âøå" },
        { english: "vodka", pinyin: "f√∫t√®jiƒÅ", meaning: "‰ºèÁâπÂä†" }
    ];

    // --- state ---
    let currentWordIndex = 0;
    let selectedWords = [];
    let selectedWordCount = 7;

    // Audio & recording
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let audioContext = null;
    let analyser = null;
    let microphone = null;
    const visualizer = document.getElementById('audio-visualizer');

    // SpeechRecognition (transcription)
    const SpeechRec = window.SpeechRecognition || window.webkitSpeechRecognition || null;
    let recog = null;
    let lastTranscript = ""; // stores last recognized text (if any)
    let recogSupported = false;

    if (SpeechRec) {
        try {
            recog = new SpeechRec();
            recog.interimResults = false;
            recog.maxAlternatives = 1;
            recog.lang = 'en-US';
            recogSupported = true;
            console.log("SpeechRecognition supported");
        } catch (e) {
            console.warn("SpeechRecognition init failed:", e);
            recogSupported = false;
        }
    } else {
        console.log("SpeechRecognition not supported in this browser.");
    }

    // DOM refs
    const settingsSection = document.getElementById('settings-section');
    const wordSection = document.getElementById('word-section');
    const recordingSection = document.getElementById('recording-section');
    const controlsSection = document.getElementById('controls');
    const progressSection = document.getElementById('progress-section');
    const chineseWordElement = document.getElementById('chinese-word');
    const pinyinElement = document.getElementById('pinyin');
    const meaningElement = document.getElementById('meaning');
    const recordButton = document.getElementById('record-btn');
    const stopButton = document.getElementById('stop-btn');
    const analyzeButton = document.getElementById('analyze-btn');
    const listenButton = document.getElementById('listen-btn');
    const nextButton = document.getElementById('next-btn');
    const newSessionButton = document.getElementById('new-session-btn');
    const feedbackElement = document.getElementById('feedback');
    const progressElement = document.getElementById('progress');
    const progressFill = document.getElementById('progress-fill');
    const recordingStatus = document.getElementById('recording-status');
    const startButton = document.getElementById('start-btn');
    const wordCountSelect = document.getElementById('word-count-select');

    // PHONETIC DICTIONARY (ASCII-style approximations)
    const phoneticDictionary = {
        "hello": ["helo", "helou", "halo", "hellou", "ellow"],
        "thank you": ["tenk ju", "sank ju", "thank yu", "tenk you", "sank you"],
        "good day": ["gud dei", "gud day", "good dei", "gud dey"],
        "i love you": ["ai lav ju", "ay lov you", "i lav yu"],
        "water": ["voter", "vater", "woter"],
        "mother": ["mader", "mather", "moter"],
        "friend": ["frend", "frind", "freind"],
        "breakfast": ["brekfast"],
        "lunch": ["lancs", "lanch"],
        "dinner": ["diner","dine"],
        "soup": ["sup"],
        "salad": ["salad"],
        "sandwich": ["sandvich","sendvics"],
        "hamburger": ["hamburger","hamb√∂rger"],
        "pizza": ["piza","pidza"],
        "spaghetti": ["spagetti"],
        "rice": ["rajs"],
        "noodles": ["nidels","nidls"],
        "dumpling": ["dampling"],
        "steamed bun": ["stimt ban","stimtban"],
        "cake": ["kek"],
        "cookie": ["kuki"],
        "chocolate": ["shokolad"],
        "ice cream": ["ajs crim","ays crem"],
        "candy": ["kendi"],
        "apple": ["apl","epl"],
        "banana": ["banana"],
        "orange": ["oranj","oradzs"],
        // ... (b≈ëv√≠thet≈ë)
    };

    // --- HELPERS: similarity, hungarian detection ---
    function calculateSimilarity(str1, str2) {
        if (!str1 || !str2) return 0;
        str1 = str1.toLowerCase();
        str2 = str2.toLowerCase();
        if (str1 === str2) return 1;
        const longer = str1.length > str2.length ? str1 : str2;
        const minLength = Math.min(str1.length, str2.length);
        let matches = 0;
        for (let i = 0; i < minLength; i++) {
            if (str1[i] === str2[i]) matches++;
        }
        return matches / longer.length;
    }

    function detectHungarian(text) {
        if (!text) return false;
        const hungarianWords = ["k√∂sz√∂n√∂m","szia","j√≥ napot","v√≠z","anya","bar√°t","igen","nem","k√©rem"];
        for (let w of hungarianWords) if (text.includes(w)) return true;
        // diacritics quick check
        if (/[√°√©√≠√≥√∂≈ë√∫√º≈±]/i.test(text)) return true;
        // characteristic Hungarian consonant clusters
        const patterns = /sz|zs|cs|gy|ty|ny|ly/;
        if (patterns.test(text)) return true;
        return false;
    }

    // PHONETIC compare (uses dictionary, exact match and similarity)
    function phoneticCompare(spokenText, targetWord) {
        const spokenClean = (spokenText || "").toLowerCase().trim();
        const targetClean = (targetWord || "").toLowerCase().trim();

        if (!spokenClean) return { match:false, score:0, type:'no_input' };

        // 1. exact
        if (spokenClean === targetClean) return { match:true, score:95, type:'perfect' };

        // 2. phonetic dictionary variants
        const variants = phoneticDictionary[targetClean] || [];
        for (let v of variants) {
            if (v === spokenClean) return { match:true, score:85, type:'phonetic' };
        }

        // 3. detect Hungarian -> reject
        if (detectHungarian(spokenClean)) return { match:false, score:15, type:'hungarian' };

        // 4. similarity fallback
        const sim = calculateSimilarity(spokenClean, targetClean);
        if (sim > 0.7) {
            return { match:true, score: Math.min(90, Math.round(60 + sim*25)), type:'partial' };
        }

        // 5. no match
        return { match:false, score: Math.round(30 + sim*20), type:'no_match' };
    }

    // --- Recognition event handlers (if supported) ---
    if (recog) {
        recog.onstart = () => {
            console.log("Recognition started");
            recordingStatus.textContent = "üéß Recognizer listening...";
        };
        recog.onresult = (ev) => {
            const text = ev.results[0][0].transcript;
            lastTranscript = text;
            console.log("Recognized:", text);
            recordingStatus.textContent = `üó£ Recognized: "${text}"`;
        };
        recog.onerror = (ev) => {
            console.warn("Recognition error:", ev.error);
            recordingStatus.textContent = `‚ö† Recognition error: ${ev.error}`;
        };
        recog.onend = () => {
            console.log("Recognition ended");
        };
    }

    // --- RECORDING / VISUALIZER (kept for UX) ---
    async function startRecording() {
        try {
            recordingStatus.textContent = "üîÑ Accessing microphone...";
            const stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate:16000, channelCount:1, echoCancellation:true, noiseSuppression:true } });
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            microphone = audioContext.createMediaStreamSource(stream);
            microphone.connect(analyser);
            analyser.fftSize = 256;
            visualizer.style.display = 'block';
            visualizeAudio();

            audioChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = e => { if (e.data && e.data.size>0) audioChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                recordingStatus.textContent = "‚úÖ Recording ready for analysis";
                analyzeButton.disabled = false;
                visualizer.style.display = 'none';
            };
            mediaRecorder.start();
            isRecording = true;
            recordButton.disabled = true;
            stopButton.disabled = false;
            analyzeButton.disabled = true;
            recordButton.classList.add('recording');
            recordingStatus.textContent = "üî¥ Recording... Speak now!";

            // Start live recognition in parallel if supported
            if (recogSupported && recog) {
                lastTranscript = "";
                try {
                    recog.lang = 'en-US';
                    recog.start();
                } catch (e) {
                    console.warn('Recognition start error', e);
                }
            }
        } catch (err) {
            console.error("Recording error:", err);
            recordingStatus.textContent = "‚ùå Microphone access denied or error";
            feedbackElement.innerHTML = "Please allow microphone access and try again";
            feedbackElement.className = 'feedback needs-work';
            feedbackElement.style.display = 'block';
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            recordButton.disabled = false;
            stopButton.disabled = true;
            recordButton.classList.remove('recording');
            recordingStatus.textContent = "‚èπÔ∏è Recording stopped";
            if (mediaRecorder.stream) mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        }
        // stop recognition if running
        try {
            if (recogSupported && recog) recog.stop();
        } catch (e) { /* ignore */ }
    }

    function visualizeAudio() {
        if (!analyser) return;
        const canvas = visualizer;
        const ctx = canvas.getContext('2d');
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        function draw() {
            if (!isRecording) return;
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width,canvas.height);
            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;
            for (let i=0;i<bufferLength;i++){
                const barHeight = dataArray[i]/2;
                ctx.fillStyle = `rgb(${barHeight+80},50,50)`;
                ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }
        draw();
    }

    // --- ANALYZE: use lastTranscript (if available), else prompt fallback ---
    async function analyzeRecording() {
        recordingStatus.textContent = "üîç Analyzing pronunciation...";
        let transcript = lastTranscript && lastTranscript.trim() ? lastTranscript.trim() : "";

        // If recognition not available or transcript empty, ask the user to type as fallback
        if (!transcript) {
            if (!recogSupported) {
                const typed = window.prompt("Speech recognition not available in this browser. Please type what you pronounced (fallback):");
                if (!typed) {
                    recordingStatus.textContent = "‚ö† No input provided";
                    return;
                }
                transcript = typed.trim();
            } else {
                // recognition supported but transcript empty: give user one more chance to use prompt
                const typed = window.prompt("Recognition couldn't detect text reliably. You can type what you said (or Cancel to abort):");
                if (!typed) {
                    recordingStatus.textContent = "‚ö† No input provided";
                    return;
                }
                transcript = typed.trim();
            }
        }

        const currentWord = selectedWords[currentWordIndex].english.toLowerCase();
        const result = phoneticCompare(transcript.toLowerCase(), currentWord.toLowerCase());
        displayPhoneticResult(result, transcript, currentWord);
        recordingStatus.textContent = "‚úÖ Analysis complete!";
    }

    // --- Displaying result (kept your styling/messages) ---
    function displayPhoneticResult(result, spokenText, targetWord) {
        let message, details, color;
        if (result.type === 'hungarian') {
            message = "‚ùå Please speak English";
            details = `You said: <strong>"${spokenText}"</strong> (Hungarian)<br>Should be: <strong>"${targetWord}"</strong> (English)`;
            color = "#e52d27";
        } else if (result.type === 'perfect') {
            message = "‚úÖ Perfect!";
            details = `Excellent pronunciation!`;
            color = "#4CAF50";
        } else if (result.match) {
            message = "‚úÖ Good!";
            details = `You said: "${spokenText}"<br>Close to: "${targetWord}"`;
            color = "#4CAF50";
        } else {
            message = "‚ö†Ô∏è Try again";
            details = `You said: "${spokenText}"<br>Should be: "${targetWord}"`;
            color = "#ff9800";
        }

        feedbackElement.innerHTML = `
            <div style="font-size:1.5em;color:${color};margin-bottom:10px;font-weight:bold;">${message}</div>
            <div style="margin:10px 0;font-size:1.1rem;">${details}</div>
            <div style="color:#666;margin-top:8px;">Score: <strong>${result.score}%</strong> | Type: ${result.type}</div>
            ${result.type === 'hungarian' ? '<div style="margin-top:10px;color:#d32f2f;font-size:0.9rem;">üí° Please speak in English, not Hungarian</div>' : ''}
        `;
        feedbackElement.className = 'feedback';
        feedbackElement.style.display = 'block';
    }

    // --- Word selection & display ---
    function selectRandomWords(count) {
        if (count === 0 || count >= fullWordDictionary.length) selectedWords = [...fullWordDictionary];
        else {
            const shuffled = [...fullWordDictionary].sort(()=>0.5 - Math.random());
            selectedWords = shuffled.slice(0, count);
        }
        currentWordIndex = 0;
    }

    function displayWord() {
        if (!selectedWords.length) return;
        const currentWord = selectedWords[currentWordIndex];
        chineseWordElement.textContent = currentWord.english;
        pinyinElement.textContent = currentWord.pinyin || "";
        meaningElement.textContent = currentWord.meaning || "";
        const progressText = `${currentWordIndex + 1}/${selectedWords.length}`;
        progressElement.textContent = progressText;
        const progressPercent = ((currentWordIndex + 1) / selectedWords.length) * 100;
        progressFill.style.width = `${progressPercent}%`;
        feedbackElement.style.display = 'none';
        recordingStatus.textContent = 'Click "Start Recording", speak, then "Analyze"';
        recordButton.disabled = false;
        stopButton.disabled = true;
        analyzeButton.disabled = true;
        recordButton.classList.remove('recording');
        visualizer.style.display = 'none';
        lastTranscript = ""; // reset last transcript for new word
    }

    // --- Start practice ---
    function startPractice() {
        selectedWordCount = parseInt(wordCountSelect.value);
        selectRandomWords(selectedWordCount);
        settingsSection.classList.add('hidden');
        wordSection.classList.remove('hidden');
        recordingSection.classList.remove('hidden');
        controlsSection.classList.remove('hidden');
        progressSection.classList.remove('hidden');
        displayWord();
    }

    // --- speak English (TTS) ---
    function speakEnglish() {
        const currentWord = selectedWords[currentWordIndex];
        if (!currentWord) return;
        if ('speechSynthesis' in window) {
            const speech = new SpeechSynthesisUtterance(currentWord.english);
            speech.lang = 'en-US';
            speech.rate = 0.9;
            window.speechSynthesis.cancel();
            window.speechSynthesis.speak(speech);
        } else {
            alert("TTS not supported in this browser.");
        }
    }

    // --- init handlers ---
    function init() {
        updatePracticeInfo();
        startButton.addEventListener('click', startPractice);
        recordButton.addEventListener('click', startRecording);
        stopButton.addEventListener('click', stopRecording);
        analyzeButton.addEventListener('click', analyzeRecording);
        listenButton.addEventListener('click', speakEnglish);
        nextButton.addEventListener('click', () => {
            currentWordIndex = (currentWordIndex + 1) % selectedWords.length;
            displayWord();
            // auto speak the new word
            setTimeout(() => speakEnglish(), 150);
        });
        newSessionButton.addEventListener('click', () => {
            settingsSection.classList.remove('hidden');
            wordSection.classList.add('hidden');
            recordingSection.classList.add('hidden');
            controlsSection.classList.add('hidden');
            progressSection.classList.add('hidden');
        });
        wordCountSelect.addEventListener('change', ()=> selectedWordCount = parseInt(wordCountSelect.value));

        // Enable analyze button only when there's recording available (handled onstop of mediaRecorder)
        // If speech recognition is supported, show hint
        if (!recogSupported) {
            recordingStatus.textContent = "Note: SpeechRecognition not available in this browser ‚Äî fallback will ask you to type the recognized text.";
        }
    }

    function updatePracticeInfo() {
        document.getElementById('total-words').textContent = fullWordDictionary.length;
    }

    // run init
    init();
    console.log("Pronunciation practice loaded (real recognition enabled where supported).");
    </script>
</body>
</html>
